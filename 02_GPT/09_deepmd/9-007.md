# dpgen/cp2k/dpdataæºç åˆ†æ

# 1. DFTæ ‡æ³¨/cp2k

## 1. cp2kæ ‡æ³¨å·¥ä½œæµ

### 1. `make_fp_cp2k` å‡½æ•°

- `make_fp_cp2k` å‡½æ•°ä»£ç å¦‚ä¸‹ï¼š

```py
def make_fp_cp2k(iter_index, jdata):
    work_path = os.path.join(make_iter_name(iter_index), fp_name)
    fp_tasks = glob.glob(os.path.join(work_path, "task.*"))
    # make cp2k input
    iter_name = make_iter_name(iter_index)
    work_path = os.path.join(iter_name, fp_name)
    if "user_fp_params" in jdata.keys():
        fp_params = jdata["user_fp_params"]
    # some users might use own inputs
    # specify the input path string
    elif "external_input_path" in jdata.keys():
        fp_params = None
        exinput_path = os.path.abspath(jdata["external_input_path"])
    else:
        fp_params = jdata["fp_params"]
    cwd = os.getcwd()
    for ii in fp_tasks:
        os.chdir(ii)
        sys_data = dpdata.System("POSCAR").data
        # make input for every task
        # if fp_params exits, make keys
        if fp_params:
            cp2k_input = make_cp2k_input(sys_data, fp_params)
        else:
            # else read from user input
            cp2k_input = make_cp2k_input_from_external(sys_data, exinput_path)
        with open("input.inp", "w") as fp:
            fp.write(cp2k_input)
            fp.close()
        # make coord.xyz used by cp2k for every task
        cp2k_coord = make_cp2k_xyz(sys_data)
        with open("coord.xyz", "w") as fp:
            fp.write(cp2k_coord)
            fp.close()
        os.chdir(cwd)

    # link pp files
    _link_fp_vasp_pp(iter_index, jdata)
```


åœ¨ FP ï¼ˆfirstâ€principlesï¼‰æ ‡æ³¨é˜¶æ®µï¼ŒDP-GEN ä¼šä½¿ç”¨ä½ åœ¨ `param.json` ä¸­é€šè¿‡ `"external_input_path"` æŒ‡å®šçš„ `template.inp` æ–‡ä»¶ï¼Œè€Œæ ¸å¿ƒæµç¨‹å¤§ä½“å¦‚ä¸‹ï¼š


1. å…¥å£å‡½æ•°ï¼š`make_fp_cp2k`

å½“æ‰§è¡Œ `dpgen run â€¦` åˆ°è¾¾ DFT æ ‡æ³¨ï¼ˆFPï¼‰è¿™ä¸€é˜¶æ®µï¼ŒDP-GEN ä¼šè°ƒç”¨

```py
make_fp_cp2k(iter_index, jdata)
```

å…¶ä¸­ `jdata` å°±æ˜¯ä» `param.json` è¯»åˆ°çš„æ•´ä¸ªé…ç½®å­—å…¸ã€‚



2. æ£€æµ‹ç”¨æˆ·è¾“å…¥ vs. æ¨¡æ¿ç”Ÿæˆ

```py
if "user_fp_params" in jdata:
    â€¦            # ï¼ˆä¸èµ°è¿™æ¡åˆ†æ”¯ï¼‰
elif "external_input_path" in jdata:
    fp_params = None
    exinput_path = os.path.abspath(jdata["external_input_path"])
else:
    fp_params = jdata["fp_params"]
```

ç”±äºåœ¨ `param.json` ä¸­æä¾›äº† `external_input_path`ï¼Œ`fp_params` è¢«ç½®ä¸º `None`ï¼Œ`exinput_path` è¢«è®¾ä¸ºä½ çš„ `template.inp` çš„ç»å¯¹è·¯å¾„ã€‚



3. éå†æ‰€æœ‰ FP ä»»åŠ¡ç›®å½•

```py
fp_tasks = glob.glob(os.path.join(work_path, "task.*"))
for ii in fp_tasks:
    os.chdir(ii)
    sys_data = dpdata.System("POSCAR").data
    â€¦
```

- è¿›å…¥æ¯ä¸€ä¸ª `task.*` å­ç›®å½•

- é€šè¿‡ `dpdata.System("POSCAR")` è¯»å–å½“å‰ç»“æ„çš„åŸå­åæ ‡å’Œæ™¶æ ¼ä¿¡æ¯ï¼Œå­˜å…¥ `sys_data`ã€‚



4. ç”Ÿæˆ CP2K è¾“å…¥æ–‡ä»¶


```py
if fp_params:
    cp2k_input = make_cp2k_input(sys_data, fp_params)
else:
    cp2k_input = make_cp2k_input_from_external(sys_data, exinput_path)
with open("input.inp", "w") as fp:
    fp.write(cp2k_input)
```

å› ä¸º `fp_params` ä¸º `None`ï¼Œæ‰€ä»¥èµ°çš„æ˜¯

```py
make_cp2k_input_from_external(sys_data, exinput_path)
```

- è¿™ä¸ªå‡½æ•°åšäº†ï¼š

  - è¯»å–åŸå§‹ template.inpï¼ˆexinput_pathï¼‰å†…å®¹åˆ°å­—ç¬¦ä¸²åˆ—è¡¨ exinput

  - åœ¨åˆ—è¡¨ä¸­å®šä½åŒ…å« "ABC" çš„é‚£ä¸€è¡Œï¼Œåˆ é™¤åŸæ¥çš„æ™¶èƒå®šä¹‰è¡Œ

  - æ ¹æ®å½“å‰ä»»åŠ¡çš„ sys_data["cells"]ï¼ˆä¸€ä¸ª 3Ã—3 æ™¶èƒçŸ©é˜µï¼‰è®¡ç®—æ–°çš„ A B C ä¸‰æ¡å‘é‡å­—ç¬¦ä¸²

  - å°†æ–°çš„æ™¶èƒè¡Œæ’å›åŸæ¨¡æ¿å¯¹åº”ä½ç½®

  - è¿”å›ä¿®æ”¹åçš„æ•´æ®µæ–‡æœ¬


5. ç”Ÿæˆ `coord.xyz`

```py
cp2k_coord = make_cp2k_xyz(sys_data)
with open("coord.xyz", "w") as fp:
    fp.write(cp2k_coord)
```

- `make_cp2k_xyz` ä¼šï¼š

  - ä» `sys_data` ä¸­å–å‡ºåŸå­ç§ç±» (`atom_names / atom_types`) å’Œåæ ‡ (`coords`)

  - æŒ‰ XYZ æ ¼å¼æ‹¼å‡ºæ¯ä¸€è¡Œ `"å…ƒç´  x y z"`ï¼Œå¹¶è¿”å›å­—ç¬¦ä¸²



6. æ¢å¤å·¥ä½œç›®å½•å¹¶é“¾æ¥èµåŠ¿æ–‡ä»¶

```py
os.chdir(cwd)
_link_fp_vasp_pp(iter_index, jdata)
```

- æœ€åï¼ŒDP-GEN ä¼šè°ƒç”¨å†…éƒ¨çš„ `_link_fp_vasp_pp`ï¼ˆåœ¨åŒä¸€æ¨¡å—é‡Œï¼‰

  - æ ¹æ® `fp_pp_path` å’Œ `fp_pp_files`ï¼Œåœ¨æ¯ä¸ª `task.*` ç›®å½•ä¸‹åˆ›å»ºåˆ°èµåŠ¿åº“çš„ç¬¦å·é“¾æ¥

  - è¿™æ · CP2K è°ƒç”¨æ—¶å°±èƒ½æ‰¾åˆ° `GTH_POTENTIALSã€BASIS_MOLOPT` ç­‰æ–‡ä»¶



- ç®€è¦æµç¨‹å›¾

```py
make_fp_cp2k()
 â”œâ”€ glob æ‹¿åˆ°æ‰€æœ‰ task.* ç›®å½•
 â”œâ”€ for each task:
 â”‚    â”œâ”€ dpdata.System("POSCAR") â†’ sys_data
 â”‚    â”œâ”€ make_cp2k_input_from_external(sys_data, template.inp)
 â”‚    â”‚     â””â”€ è¯» template.inp â†’ åˆ é™¤æ—§ CELL â†’ æ’å…¥æ–°æ™¶èƒ
 â”‚    â”œâ”€ å†™å‡º input.inp
 â”‚    â”œâ”€ make_cp2k_xyz(sys_data) â†’ å†™å‡º coord.xyz
 â””â”€ _link_fp_vasp_pp() â†’ å»ºç«‹èµåŠ¿æ–‡ä»¶é“¾æ¥
```



- [Source code for dpgen.generator.run](https://docs.deepmodeling.com/projects/dpgen/en/latest/_modules/dpgen/generator/run.html)



### 2. `_link_fp_vasp_pp`å‡½æ•°

- `_link_fp_vasp_pp`å‡½æ•°ä»£ç å¦‚ä¸‹ï¼š

```py
def _link_fp_vasp_pp(iter_index, jdata):
    fp_pp_path = jdata["fp_pp_path"]
    fp_pp_files = jdata["fp_pp_files"]
    assert os.path.exists(fp_pp_path)
    fp_pp_path = os.path.abspath(fp_pp_path)

    iter_name = make_iter_name(iter_index)
    work_path = os.path.join(iter_name, fp_name)

    fp_tasks = glob.glob(os.path.join(work_path, "task.*"))
    fp_tasks.sort()
    if len(fp_tasks) == 0:
        return
    cwd = os.getcwd()
    for ii in fp_tasks:
        os.chdir(ii)
        for jj in fp_pp_files:
            pp_file = os.path.join(fp_pp_path, jj)
            os.symlink(pp_file, jj)
        os.chdir(cwd)
```

`_link_fp_vasp_pp(iter_index, jdata)` çš„å·¥ä½œæµç¨‹

`_link_fp_vasp_pp` å‡½æ•°çš„ç›®çš„æ˜¯åœ¨æ¯ä¸ªç¬¬ä¸€æ€§åŸç†ï¼ˆFPï¼‰è®¡ç®—ä»»åŠ¡ç›®å½•å†…åˆ›å»ºæŒ‡å‘èµåŠ¿ï¼ˆPPï¼‰æ–‡ä»¶çš„ç¬¦å·é“¾æ¥ã€‚è¿™é€šå¸¸åœ¨FPè®¡ç®—ä½¿ç”¨åƒVASPè¿™æ ·çš„ä»£ç æ—¶ä½¿ç”¨ï¼Œä½†åœ¨å½“å‰ä¸Šä¸‹æ–‡ä¸­ï¼Œå³ä¾¿ `fp_style` æ˜¯ "cp2k"ï¼Œå®ƒä¼¼ä¹ä¹Ÿè¢«è°ƒç”¨æˆ–é‡ç”¨ï¼Œè¿™å¯èƒ½è¡¨æ˜CP2Kè¢«è®¾ç½®ä¸ºä½¿ç”¨VASPæ ¼å¼çš„èµåŠ¿æ–‡ä»¶ï¼Œæˆ–è€…è¿™ä¸ªé“¾æ¥æ­¥éª¤å¯¹äºæŸäº›æ–‡ä»¶ç±»å‹æ˜¯ä¸€ä¸ªæ›´é€šç”¨çš„æ“ä½œã€‚


ä»¥ä¸‹æ˜¯è¯¦ç»†çš„æ­¥éª¤åˆ†è§£ï¼š

1. è·å–å‚æ•°:
   - `fp_pp_path = jdata["fp_pp_path"]`: å®ƒä» jdataï¼ˆå³è§£æåçš„ param.json æ–‡ä»¶å†…å®¹ï¼‰ä¸­è·å–å­˜å‚¨èµåŠ¿æ–‡ä»¶çš„ç›®å½•è·¯å¾„ã€‚åœ¨ä½ çš„ `param.json` æ–‡ä»¶ä¸­ï¼Œè¿™ä¸ªå€¼æ˜¯ `"/public21/soft/cp2k/8.1/data"`ã€‚
   - `fp_pp_files = jdata["fp_pp_files"]`: å®ƒè·å–ä¸€ä¸ªåŒ…å«èµåŠ¿æ–‡ä»¶åçš„åˆ—è¡¨ã€‚åœ¨ä½ çš„ `param.json` æ–‡ä»¶ä¸­ï¼Œè¿™ä¸ªå€¼åˆå§‹æ˜¯ä¸€ä¸ªç©ºåˆ—è¡¨ `[]`ã€‚

2. éªŒè¯è·¯å¾„:
   - `assert os.path.exists(fp_pp_path)`: å®ƒæ£€æŸ¥æŒ‡å®šçš„ fp_pp_path æ˜¯å¦åœ¨æ–‡ä»¶ç³»ç»Ÿä¸Šå®é™…å­˜åœ¨ã€‚å¦‚æœä¸å­˜åœ¨ï¼Œç¨‹åºå°†å›  AssertionError è€Œç»ˆæ­¢ã€‚
   - `fp_pp_path = os.path.abspath(fp_pp_path)`: å®ƒå°† fp_pp_path è½¬æ¢ä¸ºç»å¯¹è·¯å¾„ï¼Œä»¥ç¡®ä¿å¼•ç”¨çš„æ˜ç¡®æ€§ã€‚

3. ç¡®å®šå·¥ä½œç›®å½•:
   - `iter_name = make_iter_name(iter_index)`: è¿™ä¸ªå‡½æ•°ï¼ˆä»£ç æœªå±•ç¤ºï¼Œä½†åœ¨DP-GENä¸­å¾ˆå¸¸è§ï¼‰å¯èƒ½ä¼šä¸ºå½“å‰è¿­ä»£ç”Ÿæˆä¸€ä¸ªç›®å½•åï¼ˆä¾‹å¦‚ï¼Œiter_000000ï¼‰ã€‚
   - `work_path = os.path.join(iter_name, fp_name)`: å®ƒæ„å»ºå½“å‰è¿­ä»£çš„FPå­ç›®å½•çš„è·¯å¾„ï¼ˆä¾‹å¦‚ï¼Œ`iter_000000/01.fp`ï¼Œå‡è®¾ fp_name ç±»ä¼¼äº "01.fp"ï¼‰ã€‚

4. è¯†åˆ«FPä»»åŠ¡:
   - `fp_tasks = glob.glob(os.path.join(work_path, "task.*"))`: å®ƒåœ¨ work_path ç›®å½•ä¸­æœç´¢æ‰€æœ‰åŒ¹é… `"task.*"` æ¨¡å¼çš„å­ç›®å½•ï¼Œè¿™äº›å­ç›®å½•ä»£è¡¨äº†å•ä¸ªçš„FPè®¡ç®—ä»»åŠ¡ï¼ˆä¾‹å¦‚ï¼Œ`iter_000000/01.fp/task.000.00000`, `iter_000000/01.fp/task.000.00001ï¼‰`ã€‚
   - `fp_tasks.sort()`: å¯¹æ‰¾åˆ°çš„ä»»åŠ¡ç›®å½•è¿›è¡Œæ’åºã€‚
   - `if len(fp_tasks) == 0: return`: å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»åŠ¡ç›®å½•ï¼Œå‡½æ•°å°†æå‰é€€å‡ºã€‚

5. é“¾æ¥èµåŠ¿æ–‡ä»¶:
   - `cwd = os.getcwd()`: ä¿å­˜å½“å‰çš„Pythonå·¥ä½œç›®å½•ã€‚
   - ç„¶åä»£ç ä¼šéå†æ¯ä¸ªè¯†åˆ«å‡ºçš„ fp_task ç›®å½• (`for ii in fp_tasks`):
     - `os.chdir(ii)`: å°†å½“å‰å·¥ä½œç›®å½•æ›´æ”¹ä¸ºç‰¹å®šçš„ä»»åŠ¡ç›®å½•ï¼ˆä¾‹å¦‚ï¼Œ`iter_000000/01.fp/task.000.00000`ï¼‰ã€‚
     - æ¥ç€ï¼Œå®ƒä¼šéå† `fp_pp_files` åˆ—è¡¨ä¸­çš„æ¯ä¸ªæ–‡ä»¶å jj (`for jj in fp_pp_files`):
       - `pp_file = os.path.join(fp_pp_path, jj)`: æ„å»ºåˆ°æºèµåŠ¿æ–‡ä»¶çš„å®Œæ•´è·¯å¾„ã€‚
       - `os.symlink(pp_file, jj)`: åœ¨å½“å‰ä»»åŠ¡ç›®å½•å†…åˆ›å»ºä¸€ä¸ªåä¸º jj çš„ç¬¦å·é“¾æ¥ï¼Œè¯¥é“¾æ¥æŒ‡å‘ pp_fileã€‚
     - `os.chdir(cwd)`: åœ¨å¤„ç†å®Œä¸€ä¸ªä»»åŠ¡ç›®å½•ä¸­çš„æ‰€æœ‰èµåŠ¿æ–‡ä»¶åï¼Œå°†å½“å‰å·¥ä½œç›®å½•æ”¹å›ä¹‹å‰ä¿å­˜çš„ç›®å½•ï¼Œç„¶åå¤„ç†ä¸‹ä¸€ä¸ªä»»åŠ¡ã€‚




### 3. `cp2k.py` æ¨¡å—

```py
import numpy as np

default_config = {
    "GLOBAL": {"PROJECT": "DPGEN"},
    "FORCE_EVAL": {
        "METHOD": "QS",
        "STRESS_TENSOR": "ANALYTICAL",
        "DFT": {
            "BASIS_SET_FILE_NAME": "./cp2k_basis_pp_file/BASIS_MOLOPT",
            "POTENTIAL_FILE_NAME": "./cp2k_basis_pp_file/GTH_POTENTIALS",
            "CHARGE": 0,
            "UKS": "F",
            "MULTIPLICITY": 1,
            "MGRID": {"CUTOFF": 400, "REL_CUTOFF": 50, "NGRIDS": 4},
            "QS": {"EPS_DEFAULT": "1.0E-12"},
            "SCF": {"SCF_GUESS": "ATOMIC", "EPS_SCF": "1.0E-6", "MAX_SCF": 50},
            "XC": {"XC_FUNCTIONAL": {"_": "PBE"}},
        },
        "SUBSYS": {
            "CELL": {"A": "10 .0 .0", "B": ".0 10 .0", "C": ".0 .0 10"},
            "COORD": {"@include": "coord.xyz"},
            "KIND": {
                "_": ["H", "C", "N"],
                "POTENTIAL": ["GTH-PBE-q1", "GTH-PBE-q4", "GTH-PBE-q5"],
                "BASIS_SET": ["DZVP-MOLOPT-GTH", "DZVP-MOLOPT-GTH", "DZVP-MOLOPT-GTH"],
            },
        },
        "PRINT": {"FORCES": {"_": "ON"}, "STRESS_TENSOR": {"_": "ON"}},
    },
}


def update_dict(old_d, update_d):
    """A method to recursive update dict
    :old_d: old dictionary
    :update_d: some update value written in dictionary form.
    """
    import collections.abc

    for k, v in update_d.items():
        if (
            k in old_d
            and isinstance(old_d[k], dict)
            and isinstance(update_d[k], collections.abc.Mapping)
        ):
            update_dict(old_d[k], update_d[k])
        else:
            old_d[k] = update_d[k]


def iterdict(d, out_list, flag=None, indent=0):
    """
    :doc: a recursive expansion of dictionary into cp2k input
    :k: current key
    :v: current value
    :d: current dictionary under expansion
    :flag: used to record dictionary state. if flag is None,
    it means we are in top level dict. flag is a string.
    :indent: intent for current section.
    """
    for k, v in d.items():
        k = str(k)  # cast key into string
        # if value is dictionary
        if isinstance(v, dict):
            # flag == None, it is now in top level section of cp2k
            if flag is None:
                out_list.append("&" + k)
                out_list.append("&END " + k)
                iterdict(v, out_list, k, indent + 2)
            # flag is not None, now it has name of section
            else:
                index = out_list.index(" " * (indent - 2) + "&END " + flag)
                out_list.insert(index, " " * indent + "&" + k + " #" + flag)
                out_list.insert(index + 1, " " * indent + "&END " + k + " #" + flag)
                # the flag now contains its parent section name, separed by "#".
                iterdict(v, out_list, k + " #" + flag, indent + 2)
        elif isinstance(v, list):
            #            print("we have encountered the repeat section!")
            index = out_list.index(" " * (indent - 2) + "&" + flag)
            # delete the current constructed repeat section
            del out_list[index : index + 2]
            # do a loop over key and corresponding list
            k_tmp_list = []
            v_list_tmp_list = []
            for k_tmp, v_tmp in d.items():
                k_tmp_list.append(str(k_tmp))
                v_list_tmp_list.append(v_tmp)
            for repeat_keyword in zip(*v_list_tmp_list):
                out_list.insert(index, " " * (indent - 2) + "&" + flag)
                out_list.insert(index + 1, " " * (indent - 2) + "&END " + flag)
                for idx, k_tmp in enumerate(k_tmp_list):
                    if k_tmp == "_":
                        out_list[index] = (
                            " " * (indent - 2)
                            + "&"
                            + flag.split(" #")[0]
                            + " "
                            + repeat_keyword[idx]
                        )
                    else:
                        out_list.insert(
                            index + 1,
                            " " * (indent) + k_tmp + " " + repeat_keyword[idx],
                        )
            break

        else:
            v = str(v)
            if flag is None:
                out_list.append(k + " " + v)
                print(k, ":", v)
            else:
                if k == "_":
                    index = out_list.index(" " * (indent - 2) + "&" + flag)
                    out_list[index] = (
                        " " * (indent - 2) + "&" + flag.split(" #")[0] + " " + v
                    )

                else:
                    index = out_list.index(" " * (indent - 2) + "&END " + flag)
                    out_list.insert(index, " " * indent + k + " " + v)


def make_cp2k_input(sys_data, fp_params):
    # covert cell to cell string
    cell = sys_data["cells"][0]
    cell = np.reshape(cell, [3, 3])
    cell_a = np.array2string(cell[0, :])
    cell_a = cell_a[1:-1]
    cell_b = np.array2string(cell[1, :])
    cell_b = cell_b[1:-1]
    cell_c = np.array2string(cell[2, :])
    cell_c = cell_c[1:-1]

    # get update from user
    user_config = fp_params
    # get update from cell
    cell_config = {
        "FORCE_EVAL": {"SUBSYS": {"CELL": {"A": cell_a, "B": cell_b, "C": cell_c}}}
    }
    update_dict(default_config, user_config)
    update_dict(default_config, cell_config)
    # output list
    input_str = []
    iterdict(default_config, input_str)
    string = "\n".join(input_str)
    return string


def make_cp2k_xyz(sys_data):
    # get structral information
    atom_names = sys_data["atom_names"]
    atom_types = sys_data["atom_types"]

    # write coordinate to xyz file used by cp2k input
    coord_list = sys_data["coords"][0]
    u = np.array(atom_names)
    atom_list = u[atom_types]
    x = "\n"
    for kind, coord in zip(atom_list, coord_list):
        x += str(kind) + " " + str(coord[:])[1:-1] + "\n"
    return x


def make_cp2k_input_from_external(sys_data, exinput_path):
    # read the input content as string
    with open(exinput_path) as f:
        exinput = f.readlines()

    # find the ABC cell string
    for line_idx, line in enumerate(exinput):
        if "ABC" in line:
            delete_cell_idx = line_idx
            delete_cell_line = line

    # remove the useless CELL line
    exinput.remove(delete_cell_line)

    # insert the cell information
    # covert cell to cell string
    cell = sys_data["cells"][0]
    cell = np.reshape(cell, [3, 3])
    cell_a = np.array2string(cell[0, :])
    cell_a = cell_a[1:-1]
    cell_b = np.array2string(cell[1, :])
    cell_b = cell_b[1:-1]
    cell_c = np.array2string(cell[2, :])
    cell_c = cell_c[1:-1]

    exinput.insert(delete_cell_idx, "A  " + cell_a + "\n")
    exinput.insert(delete_cell_idx + 1, "B  " + cell_b + "\n")
    exinput.insert(delete_cell_idx + 2, "C  " + cell_c + "\n")

    return "".join(exinput)
```


### 4. dpgenå·¥ä½œæµåˆ†æ


å½“ `param.json` é…ç½®äº† `fp_style: "cp2k"` å’Œ `external_input_path` æ—¶ï¼Œdpgen çš„FPé˜¶æ®µä¼šæ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

1. å¯¹äºæ¯ä¸€ä¸ªéœ€è¦è¿›è¡ŒDFTè®¡ç®—çš„ç»“æ„ (æ¥è‡ª `sys_configs` æŒ‡å®šçš„ `POSCAR` æ–‡ä»¶)ï¼š

2. è°ƒç”¨ `make_fp_cp2k` (`from dpgen.generator.run`)ã€‚

3. è¯¥å‡½æ•°è¿›è€Œè°ƒç”¨ `make_cp2k_input_from_external` (`from cp2k.py`)ï¼Œå®ƒä¼šï¼š
 
   - è¯»å–ç”¨æˆ·æä¾›çš„ `template.inp`ã€‚

   - å°† `template.inp` ä¸­çš„å ä½æ™¶èƒè¡Œï¼ˆåŒ…å« `"ABC"`` çš„é‚£è¡Œï¼‰æ›¿æ¢ä¸ºä»å½“å‰ç»“æ„ POSCAR æ–‡ä»¶ä¸­è¯»å–çš„å®é™…æ™¶èƒå‚æ•°ã€‚
 
   - ç”Ÿæˆæœ€ç»ˆçš„ `input.inp` æ–‡ä»¶å†…å®¹ã€‚

4. è°ƒç”¨ `make_cp2k_xyz` (`from cp2k.py`)ï¼Œå®ƒä¼šï¼š

   - ä»å½“å‰ç»“æ„ `POSCAR` æ–‡ä»¶ä¸­è¯»å–åŸå­ç±»å‹å’Œåæ ‡ã€‚

   - ç”Ÿæˆä¸€ä¸ª `coord.xyz` æ–‡ä»¶å†…å®¹ï¼Œè¯¥æ–‡ä»¶ä¼šè¢« `input.inp` ä¸­çš„ `@include ${COORDFILE}` æŒ‡ä»¤å¼•ç”¨ã€‚

5. å°†ç”Ÿæˆçš„ `input.inp` å’Œ `coord.xyz` æ–‡ä»¶å†™å…¥åˆ°æ¯ä¸ªDFTä»»åŠ¡çš„å­ç›®å½•ä¸­ã€‚

6. å¤„ç†èµåŠ¿å’ŒåŸºç»„æ–‡ä»¶çš„é“¾æ¥æˆ–è·¯å¾„è®¾ç½®ï¼Œä»¥ä¾¿CP2Kå¯ä»¥æ‰¾åˆ°å®ƒä»¬ã€‚

ä¹‹åï¼Œdpgen ä¼šåœ¨æ¯ä¸ªä»»åŠ¡å­ç›®å½•ä¸­å¯åŠ¨CP2Kç¨‹åºï¼Œä½¿ç”¨ç”Ÿæˆçš„ `input.inp` å’Œ `coord.xyz` æ–‡ä»¶æ‰§è¡ŒDFTè®¡ç®—ã€‚CP2Kä¼šè‡ªè¡Œå¤„ç† `template.inp` ä¸­å®šä¹‰çš„ `@SET` å˜é‡å’Œ `@include` ç­‰æŒ‡ä»¤ã€‚





# 2. cp2kæºç 

## 1. å•ä½åŠè½¬æ¢ç³»æ•°

### 1. åŸºæœ¬å¸¸æ•°å’Œè½¬æ¢å…¬å¼

æœ‰å…³ CP2K åœ¨ç¼–è¯‘æ—¶ä¼šç¼–è¯‘è¿›ä¸€ç»„é¢„å®šä¹‰çš„å•ä½ï¼Œè¿™ä»½å•ä½åœ¨githubä¸­çš„å…·ä½“åœ°å€ï¼Œä»¥ä¾¿æˆ‘æŸ¥çœ‹æ˜¯å¦æœ‰æˆ‘æƒ³è¦çš„å•ä½ï¼Œä»¥åŠå…·ä½“è½¬æ¢æ•°å€¼

- å•ä½ï¼šhttps://github.com/cp2k/cp2k/blob/master/src/common/cp_units.F

- å•ä½å’Œè½¬æ¢ç³»æ•°ï¼šhttps://github.com/cp2k/cp2k/blob/master/src/common/physcon.F

```
! é€Ÿåº¦å¸¸æ•°
c_light       = 299792458.0_dp
c_light_au    = 137.035999679_dp

! çœŸç©ºç£å¯¼ç‡
mu_perm       = 4.0_dp*pi*1.0E-7_dp

! çœŸç©ºä»‹ç”µå¸¸æ•° Îµâ‚€ = 1 / (Î¼â‚€Â·cÂ²)
permittivity  = 1.0_dp / (mu_perm * c_light**2)

! æ™®æœ—å…‹å¸¸æ•° h, åŠçº¦åŒ–æ™®æœ—å…‹å¸¸æ•° Ä§ = h/(2Ï€)
h_planck      = 6.62606896E-34_dp
h_bar         = h_planck / (2.0_dp * pi)

! å…ƒç”µè·ã€ç”µå­è´¨é‡ã€è´¨å­è´¨é‡ã€ç”µå­ g å› å­
e_charge      = 1.602176487E-19_dp
e_mass        = 9.10938215E-31_dp
p_mass        = 1.672621637E-27_dp
e_gfactor     = -2.0023193043622_dp

! ç»†ç»“æ„å¸¸æ•° Î± å’Œ Rydberg å¸¸æ•°
a_fine        = 7.2973525376E-3_dp
rydberg       = 10973731.568527_dp

! é˜¿ä¼ä¼½å¾·ç½—å¸¸æ•°å’Œç»å°”å…¹æ›¼å¸¸æ•°
n_avogadro    = 6.02214179E+23_dp
boltzmann     = 1.3806504E-23_dp

! åŸå­è´¨é‡å•ä½ï¼ˆkgï¼‰å’Œ Bohr åŠå¾„ï¼ˆmï¼‰
a_mass        = 1.660538782E-27_dp
a_bohr        = 0.52917720859E-10_dp

```

### 2. åŠ›å•ä½è½¬æ¢ç¤ºä¾‹1

åŸºäºä¸Šè¿°ä»£ç ä¸­å„å•ä½ä¹‹é—´çš„è½¬æ¢ç³»æ•°ï¼Œä¸ºäº†å¾—åˆ°æœ€é«˜ç²¾åº¦çš„ `amu*angstrom/fs^2` ä¸ `Hartree/Bohr`  ä¹‹é—´çš„è½¬æ¢ç³»æ•°ï¼Œä½¿ç”¨pythonç¼–ç¨‹æ¥è®¡ç®—è½¬æ¢ç³»æ•°ã€‚


```py
# -*- coding: utf-8 -*-
"""
è®¡ç®— 1 amuÂ·Ã…/fs^2 ä¸ 1 Hartree/Bohr ä¹‹é—´çš„ç›¸äº’è½¬æ¢ç³»æ•°ï¼ˆåŸºäº CP2K CODATA 2006 å¸¸æ•°ï¼‰ã€‚
"""

import numpy as np

# 1. å®šä¹‰ CP2K ä¸­ä½¿ç”¨çš„ç‰©ç†å¸¸æ•°ï¼ˆCODATA 2006ï¼‰
h_planck = 6.62606896e-34  # æ™®æœ—å…‹å¸¸æ•° [JÂ·s]
c_light = 299792458.0      # å…‰é€Ÿ [m/s]
rydberg = 10973731.568527   # é‡Œå¾·ä¼¯å¸¸æ•° [1/m]
a_bohr = 0.52917720859e-10  # ç»å°”åŠå¾„ [m]

# 2. è®¡ç®— Hartree èƒ½é‡ [J]
hartree = 2.0 * rydberg * h_planck * c_light

# 3. è®¡ç®— Hartree/Bohr å¯¹åº”çš„åŠ› [N]
force_hartree_per_bohr = hartree / a_bohr

# 4. å®šä¹‰ amuã€Ã…ã€fs å¯¹åº”çš„ SI å•ä½
a_mass = 1.660538782e-27   # åŸå­è´¨é‡å•ä½ [kg]
angstrom = 1.0e-10         # 1 Ã… = 1e-10 m
fs = 1.0e-15               # 1 fs = 1e-15 s

# 5. è®¡ç®— 1 amuÂ·Ã…/fs^2 å¯¹åº”çš„åŠ› [N]
force_amuA_fs2 = a_mass * angstrom / (fs**2)

# 6. è®¡ç®—è½¬æ¢ç³»æ•°ï¼š1 Hartree/Bohr ç­‰äºå¤šå°‘ amuÂ·Ã…/fs^2
h2a = force_hartree_per_bohr / force_amuA_fs2  # Hartree/Bohr -> amuÂ·Ã…/fsÂ²

# 7. è®¡ç®—é€†è½¬æ¢ç³»æ•°ï¼š1 amuÂ·Ã…/fs^2 ç­‰äºå¤šå°‘ Hartree/Bohr
a2h = 1.0 / h2a  # amuÂ·Ã…/fsÂ² -> Hartree/Bohr

# 8. è¾“å‡ºç»“æœ
print(f"1 Hartree = {hartree:.12e} J")
print(f"1 Bohr    = {a_bohr:.12e} m")
print(f"1 Hartree/Bohr å¯¹åº”çš„åŠ› = {force_hartree_per_bohr:.12e} N")
print(f"1 amuÂ·Ã…/fsÂ² å¯¹åº”çš„åŠ›   = {force_amuA_fs2:.12e} N")
print(f"è½¬æ¢ç³»æ•° 1 (Hartree/Bohr -> amuÂ·Ã…/fsÂ²) = {h2a:.12f}")
print(f"è½¬æ¢ç³»æ•° 2 (amuÂ·Ã…/fsÂ² -> Hartree/Bohr) = {a2h:.12f}")
```

- è¾“å‡ºç»“æœ

```
1 Hartree = 4.359743939371e-18 J
1 Bohr    = 5.291772085900e-11 m
1 Hartree/Bohr å¯¹åº”çš„åŠ› = 8.238722054918e-08 N
1 amuÂ·Ã…/fsÂ² å¯¹åº”çš„åŠ›   = 1.660538782000e-07 N
è½¬æ¢ç³»æ•° 1 (Hartree/Bohr -> amuÂ·Ã…/fsÂ²) = 0.496147524179
è½¬æ¢ç³»æ•° 2 (amuÂ·Ã…/fsÂ² -> Hartree/Bohr) = 2.015529557777
```


### 3. åŠ›å•ä½è½¬æ¢ç¤ºä¾‹2

åŸºäºä¸Šè¿°ä»£ç ä¸­å„å•ä½ä¹‹é—´çš„è½¬æ¢ç³»æ•°ï¼Œä¸ºäº†å¾—åˆ°æœ€é«˜ç²¾åº¦çš„ `amu*angstrom/fs^2` ä¸ `Hartree/Bohr`  ä¹‹é—´çš„è½¬æ¢ç³»æ•°ï¼Œä½¿ç”¨pythonç¼–ç¨‹æ¥è®¡ç®—è½¬æ¢ç³»æ•°ã€‚

```py
from decimal import Decimal, getcontext

# Set precision for Decimal calculations (higher than inputs)
getcontext().prec = 60 # Sufficiently high precision

# Constants from the Fortran code (CODATA 2006)
# Fundamental constants in SI units
c_light_val = Decimal("299792458.0")        # m/s
h_planck_val = Decimal("6.62606896E-34")    # J*s
e_charge_val = Decimal("1.602176487E-19")   # C
e_mass_val = Decimal("9.10938215E-31")      # kg
rydberg_val = Decimal("10973731.568527")    # 1/m
a_mass_val = Decimal("1.660538782E-27")     # Atomic mass unit [kg]
a_bohr_val = Decimal("0.52917720859E-10")   # Bohr radius [m]

# Calculate Hartree energy in Joules (named 'joule' in Fortran code)
# joule = 2.0_dp*rydberg*h_planck*c_light
hartree_in_J = Decimal("2.0") * rydberg_val * h_planck_val * c_light_val

# LHS: 1 amu * Angstrom / fs^2 in SI (kg*m/s^2)
amu_kg = a_mass_val
angstrom_m = Decimal("1E-10")   # 1 Angstrom in meters
fs_s = Decimal("1E-15")       # 1 femtosecond in seconds

lhs_si_value = (amu_kg * angstrom_m) / (fs_s**2)
# This can be simplified: (amu_kg * 1E-10) / 1E-30 = amu_kg * 1E+20

# RHS: 1 Hartree / Bohr in SI (J/m which is kg*m/s^2)
rhs_si_value = hartree_in_J / a_bohr_val

# Conversion factor X
conversion_factor = lhs_si_value / rhs_si_value

print(f"Constants used from Fortran (CODATA 2006):")
print(f"  a_mass (amu in kg): {a_mass_val}")
print(f"  a_bohr (Bohr radius in m): {a_bohr_val}")
print(f"  Rydberg constant (1/m): {rydberg_val}")
print(f"  Planck constant (J*s): {h_planck_val}")
print(f"  Speed of light (m/s): {c_light_val}")
print("-" * 40)
print(f"Calculated Hartree energy in Joules: {hartree_in_J:.15E}")
print("-" * 40)
print(f"LHS (1 amu * A / fs^2) in SI (kg*m/s^2): {lhs_si_value:.15E}")
print(f"RHS (1 Hartree / Bohr) in SI (kg*m/s^2): {rhs_si_value:.15E}")
print("-" * 40)
print(f"Conversion factor (X): {conversion_factor:.15E}")
print(f"To express more precisely: {conversion_factor}")
```

- è¾“å‡ºç»“æœ

```
Constants used from Fortran (CODATA 2006):
  a_mass (amu in kg): 1.660538782E-27
  a_bohr (Bohr radius in m): 5.2917720859E-11
  Rydberg constant (1/m): 10973731.568527
  Planck constant (J*s): 6.62606896E-34
  Speed of light (m/s): 299792458.0
----------------------------------------
Calculated Hartree energy in Joules: 4.359743939370588E-18
----------------------------------------
LHS (1 amu * A / fs^2) in SI (kg*m/s^2): 1.660538782000000E-7
RHS (1 Hartree / Bohr) in SI (kg*m/s^2): 8.238722054918401E-8
----------------------------------------
Conversion factor (X): 2.015529557777327E+0
To express more precisely: 2.01552955777732746003145182366014911073189555086572565099919
```




# 3. dpdataæºç 

## 1. `dpdata/plugins/cp2k.py`

- æºç åœ°å€ï¼šhttps://github.com/deepmodeling/dpdata/blob/master/dpdata/plugins/cp2k.py

è¿™æ®µä»£ç æ˜¯å…³äº **`dpdata` åº“ä¸­ç”¨äºå¤„ç† CP2K æ¨¡æ‹Ÿè½¯ä»¶è¾“å‡ºæ–‡ä»¶çš„æ¨¡å—**ã€‚

å…·ä½“æ¥è¯´ï¼Œå®ƒå®šä¹‰äº†ä¸¤ä¸ªç±»ï¼Œç”¨äºå°† CP2K çš„è¾“å‡ºæ•°æ®è½¬æ¢ä¸º `dpdata` åº“å¯ä»¥ç†è§£å’Œå¤„ç†çš„æ ¼å¼ï¼š

### 1. `CP2KAIMDOutputFormat` (æ³¨å†Œä¸º `"cp2k/aimd_output"`)

* è¿™ä¸ªç±»ä¸“é—¨ç”¨äºå¤„ç† **CP2K è¿›è¡Œä»å¤´ç®—åˆ†å­åŠ¨åŠ›å­¦ (AIMD) æ¨¡æ‹Ÿ**çš„è¾“å‡ºæ–‡ä»¶ã€‚
* å®ƒçš„ `from_labeled_system` æ–¹æ³•ä¼šå°è¯•ä»æŒ‡å®šçš„æ–‡ä»¶å¤¹ (`file_name`) ä¸­æ‰¾åˆ° `.xyz` æ ¼å¼çš„åæ ‡æ–‡ä»¶ (ä¾‹å¦‚ `*pos*.xyz`) å’Œ `.log` æ ¼å¼çš„æ—¥å¿—æ–‡ä»¶ã€‚
* ç„¶åï¼Œå®ƒä½¿ç”¨ `dpdata.cp2k.output.Cp2kSystems` æ¥è§£æè¿™äº›æ–‡ä»¶ï¼Œæå–æ¨¡æ‹Ÿè½¨è¿¹ä¸­çš„å„ä¸ªå¸§ (frames) çš„ä¿¡æ¯ã€‚
* å¦‚æœè§£æè¿‡ç¨‹ä¸­å‡ºç° `StopIteration` (é€šå¸¸è¡¨ç¤ºæ¨¡å¼åŒ¹é…å¤±è´¥ï¼Œå³æ–‡ä»¶å†…å®¹ä¸ç¬¦åˆé¢„æœŸæ ¼å¼) æˆ– `RuntimeError`ï¼Œå®ƒä¼šæŠ›å‡ºä¸€ä¸ª `PendingDeprecationWarning`ï¼Œå¹¶æ˜¾ç¤ºä¸€æ¡è­¦å‘Šä¿¡æ¯ (`string_warning`)ã€‚è¿™æ¡è­¦å‘Šä¿¡æ¯æç¤ºç”¨æˆ·æ£€æŸ¥ CP2K æ–‡ä»¶æ˜¯å¦å®Œæ•´ï¼Œæˆ–è€…å…¶ç‰ˆæœ¬æ˜¯å¦ä¸ `dpdata` å…¼å®¹ï¼Œå¹¶å»ºè®®å°è¯•ä½¿ç”¨ `cp2kdata` æ’ä»¶ã€‚

### 2. `CP2KOutputFormat` (æ³¨å†Œä¸º `"cp2k/output"`)

* è¿™ä¸ªç±»ç”¨äºå¤„ç†**æ›´é€šç”¨çš„ CP2K è¾“å‡ºæ–‡ä»¶**ã€‚
* å®ƒçš„ `from_labeled_system` æ–¹æ³•ç›´æ¥è°ƒç”¨ `dpdata.cp2k.output.get_frames(file_name)` å‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°è´Ÿè´£ä» CP2K è¾“å‡ºæ–‡ä»¶ä¸­æå–å…³é”®æ•°æ®ï¼ŒåŒ…æ‹¬ï¼š
    * `atom_names` (åŸå­åç§°)
    * `atom_numbs` (å„ç±»åŸå­çš„æ•°é‡)
    * `atom_types` (åŸå­ç±»å‹)
    * `cells` (æ™¶èƒå‚æ•°)
    * `coords` (åŸå­åæ ‡)
    * `energies` (èƒ½é‡)
    * `forces` (åŸå­å—åŠ›)
    * `tmp_virial` (ç»´é‡Œï¼Œå¦‚æœå­˜åœ¨)
* å¦‚æœæˆåŠŸæå–åˆ°ç»´é‡Œï¼Œå®ƒä¼šå°†å…¶æ·»åŠ åˆ°è¿”å›çš„æ•°æ®å­—å…¸ä¸­ã€‚
* å¦‚æœåœ¨æå–è¿‡ç¨‹ä¸­å‘ç”Ÿ `RuntimeError` (ä»£ç æ³¨é‡Šä¸­æåˆ°è¿™å¯èƒ½ç”¨äºæ•è·æ¨¡å¼åŒ¹é…å¤±è´¥ç­‰é”™è¯¯)ï¼Œå®ƒåŒæ ·ä¼šæŠ›å‡º `PendingDeprecationWarning` å¹¶æ˜¾ç¤º `string_warning`ã€‚

---

**æ€»è€Œè¨€ä¹‹ï¼Œè¿™éƒ¨åˆ†ä»£ç æ˜¯ `dpdata` æ¡†æ¶çš„ä¸€éƒ¨åˆ†ï¼Œå…¶æ ¸å¿ƒåŠŸèƒ½æ˜¯ä½œä¸º CP2K è¾“å‡ºæ–‡ä»¶çš„è§£æå™¨ã€‚å®ƒä½¿å¾—ç”¨æˆ·èƒ½å¤Ÿé€šè¿‡ `dpdata` æ–¹ä¾¿åœ°è¯»å– CP2K çš„æ¨¡æ‹Ÿç»“æœï¼ˆå¦‚åŸå­ç»“æ„ã€èƒ½é‡ã€åŠ›ç­‰ï¼‰ï¼Œå¹¶å°†è¿™äº›æ•°æ®åŠ è½½åˆ° `dpdata` çš„æ•°æ®ç»“æ„ä¸­ï¼Œä»¥ä¾¿è¿›è¡Œåç»­çš„åˆ†æã€å¤„ç†æˆ–è½¬æ¢æˆå…¶ä»–æ ¼å¼ã€‚** åŒæ—¶ï¼Œå®ƒä¹ŸåŒ…å«äº†ä¸€äº›åŸºæœ¬çš„é”™è¯¯å¤„ç†å’Œç”¨æˆ·æç¤ºæœºåˆ¶ã€‚





## 2. `dpdata/cp2k/cell.py`

æºç åœ°å€ï¼šhttps://github.com/deepmodeling/dpdata/blob/master/dpdata/cp2k/cell.py

è¿™æ®µ `dpdata` æºç ä¸­çš„ Python ä»£ç å®šä¹‰äº†ä¸€ä¸ªåä¸º `cell_to_low_triangle` çš„å‡½æ•°ã€‚

å…¶ä¸»è¦åŠŸèƒ½æ˜¯**å°†æ™¶èƒå‚æ•°ï¼ˆä¸‰ä¸ªè¾¹é•¿ A, B, C å’Œä¸‰ä¸ªè§’ Î±, Î², Î³ï¼‰è½¬æ¢ä¸ºä¸€ä¸ªä¸‹ä¸‰è§’çŸ©é˜µå½¢å¼çš„æ™¶èƒè¡¨ç¤º**ã€‚è¿™ç§çŸ©é˜µè¡¨ç¤ºåœ¨åˆ†å­åŠ¨åŠ›å­¦æ¨¡æ‹Ÿå’Œææ–™ç§‘å­¦è®¡ç®—ä¸­éå¸¸å¸¸è§ã€‚

---

### 1. å‚æ•° (Parameters)

* `A` (`float`): æ™¶èƒè¾¹é•¿ Aã€‚
* `B` (`float`): æ™¶èƒè¾¹é•¿ Bã€‚
* `C` (`float`): æ™¶èƒè¾¹é•¿ Cã€‚
* `alpha` (`float`): æ™¶èƒè§’ Î± (å‘é‡ **B** å’Œ **C** ä¹‹é—´çš„å¤¹è§’)ï¼Œå•ä½ä¸º**å¼§åº¦ (radian)**ã€‚
* `beta` (`float`): æ™¶èƒè§’ Î² (å‘é‡ **A** å’Œ **C** ä¹‹é—´çš„å¤¹è§’)ï¼Œå•ä½ä¸º**å¼§åº¦ (radian)**ã€‚
* `gamma` (`float`): æ™¶èƒè§’ Î³ (å‘é‡ **A** å’Œ **B** ä¹‹é—´çš„å¤¹è§’)ï¼Œå•ä½ä¸º**å¼§åº¦ (radian)**ã€‚
    * *æ³¨æ„ï¼šæ ¹æ®æ ‡å‡†çº¦å®šå’Œè®¡ç®—ï¼Œ`gamma` æ˜¯å‘é‡ **A** å’Œ **B** ä¹‹é—´çš„å¤¹è§’ã€‚*

---
### 2. è¾“å…¥æ£€æŸ¥ (Input Checks)

å‡½æ•°ä¼šè¿›è¡Œä¸€ç³»åˆ—æ£€æŸ¥ä»¥ç¡®ä¿è¾“å…¥å‚æ•°çš„æœ‰æ•ˆæ€§ï¼š

* **è§’åº¦èŒƒå›´**: `alpha`, `beta`, `gamma` å¿…é¡»åœ¨çº¦ 5 åº¦åˆ° 175 åº¦ä¹‹é—´ (å³ $\frac{5\pi}{180}$ åˆ° $\frac{175\pi}{180}$ å¼§åº¦)ã€‚è¶…å‡ºæ­¤èŒƒå›´ä¼šå¼•å‘ `RuntimeError`ã€‚
* **è¾¹é•¿å¤§å°**: `A`, `B`, `C` å¿…é¡»å¤§äº 0.2ã€‚å¦åˆ™ä¼šå¼•å‘ `RuntimeError`ã€‚
* **ä¸­é—´é‡æ£€æŸ¥**:
    * è®¡ç®—å¾—åˆ°çš„ `ly` (æ™¶èƒå‘é‡ **b** çš„ y åˆ†é‡) å¿…é¡»å¤§äº 0.1ã€‚
    * è®¡ç®—å¾—åˆ°çš„ `lz^2` (æ™¶èƒå‘é‡ **c** çš„ z åˆ†é‡çš„å¹³æ–¹) å¿…é¡»å¤§äº 0.01ã€‚

---
### 3. è®¡ç®—è¿‡ç¨‹ (Calculation)

å‡½æ•°æŒ‰ç…§çº¦å®šï¼ˆé€šå¸¸ç¬¬ä¸€ä¸ªæ™¶èƒå‘é‡ **a** æ²¿ x è½´ï¼Œç¬¬äºŒä¸ªæ™¶èƒå‘é‡ **b** åœ¨ xy å¹³é¢å†…ï¼‰è®¡ç®—ä¸‹ä¸‰è§’çŸ©é˜µçš„å…ƒç´ ï¼š

* `lx = A`
* `xy = B * np.cos(gamma)`
* `xz = C * np.cos(beta)`
* `ly = B * np.sin(gamma)`
* `yz = (B * C * np.cos(alpha) - xy * xz) / ly`
* `lz = np.sqrt(C**2 - xz**2 - yz**2)`

---
### 4. è¿”å›å€¼ (Returns)

* `cell` (`np.ndarray`): ä¸€ä¸ª 3x3 çš„ NumPy æ•°ç»„ï¼Œæ•°æ®ç±»å‹ä¸º `float32`ï¼Œè¡¨ç¤ºä¸ºä¸‹ä¸‰è§’çŸ©é˜µï¼š

    ```
    [[lx,  0,  0],
     [xy, ly,  0],
     [xz, yz, lz]]
    ```

    è¯¥çŸ©é˜µçš„è¡Œå‘é‡é€šå¸¸å®šä¹‰äº†æ™¶èƒçš„ä¸‰ä¸ªåŸºå‘é‡ï¼š
    * **a** = `[lx, 0, 0]`
    * **b** = `[xy, ly, 0]`
    * **c** = `[xz, yz, lz]`

---
**æ€»ç»“æ¥è¯´ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªå·¥å…·å‡½æ•°ï¼Œå®ƒæ¥æ”¶æè¿°æ™¶èƒå‡ ä½•å½¢çŠ¶çš„å…­ä¸ªæ ‡å‡†å‚æ•°ï¼Œå¹¶è¾“å‡ºä¸€ä¸ªå¯ä»¥ç›´æ¥ç”¨äºè®¸å¤šæ¨¡æ‹Ÿå’Œåˆ†æç¨‹åºçš„ä¸‹ä¸‰è§’çŸ©é˜µè¡¨ç¤ºã€‚å®ƒè¿˜åŒ…å«è¾“å…¥å€¼çš„åˆç†æ€§æ£€æŸ¥ï¼Œä»¥é˜²æ­¢æ— æ•ˆçš„æ™¶èƒå‚æ•°å¯¼è‡´è®¡ç®—é”™è¯¯ã€‚**




## 3. dpdata/cp2k/output.py

æºç åœ°å€ï¼šhttps://github.com/deepmodeling/dpdata/blob/master/dpdata/cp2k/output.py


è¿™éƒ¨åˆ† `dpdata` æºç ä¸»è¦ç”¨äº**è§£æ CP2K (ä¸€ä¸ªæµè¡Œçš„é‡å­åŒ–å­¦å’Œå›ºæ€ç‰©ç†è½¯ä»¶åŒ…) çš„è¾“å‡ºæ–‡ä»¶**ï¼Œä»ä¸­æå–æ¨¡æ‹Ÿæ•°æ®ï¼Œå¦‚åŸå­ç»“æ„ã€èƒ½é‡ã€åŠ›ã€æ™¶èƒå‚æ•°å’Œåº”åŠ›ã€‚å®ƒåŒ…å«ä¸€ä¸ªç±» `Cp2kSystems` å’Œä¸€ä¸ªè¾…åŠ©å‡½æ•° `get_frames`ã€‚

---
### 1. `Cp2kSystems` ç±» âš™ï¸

è¿™ä¸ªç±»è®¾è®¡ç”¨äºå¤„ç† CP2K çš„ `.log` æ–‡ä»¶ (åŒ…å«èƒ½é‡ã€åŠ›ã€æ™¶èƒç­‰ä¿¡æ¯) å’Œ `.xyz` æ–‡ä»¶ (åŒ…å«åŸå­åæ ‡å’Œèƒ½é‡)ã€‚å®ƒé€šè¿‡è¿­ä»£å™¨çš„æ–¹å¼é€å¸§è¯»å–å’Œè§£ææ¨¡æ‹Ÿè½¨è¿¹ã€‚

#### ä¸»è¦åŠŸèƒ½å’Œç‰¹ç‚¹:

* **åˆå§‹åŒ– (`__init__`)**:
    * æ¥æ”¶ CP2K çš„ `.log` æ–‡ä»¶åå’Œ `.xyz` æ–‡ä»¶åä½œä¸ºè¾“å…¥ã€‚
    * æ‰“å¼€è¿™ä¸¤ä¸ªæ–‡ä»¶ï¼Œå¹¶åˆ›å»ºå„è‡ªçš„ "block generator" (`log_block_generator` å’Œ `xyz_block_generator`)ï¼Œç”¨äºæŒ‰å¸§åˆ†å‰²æ–‡ä»¶å†…å®¹ã€‚
    * åŒ…å«ä¸€ä¸ª `restart` æ ‡å¿—ï¼Œè‹¥ä¸º `True`ï¼Œä¼šé¢„å¤„ç†ä¸€å¸§æ—¥å¿—æ•°æ®ã€‚

* **æ–‡ä»¶å…³é—­ (`__del__`)**:
    * ç¡®ä¿åœ¨å¯¹è±¡é”€æ¯æ—¶å…³é—­å·²æ‰“å¼€çš„æ–‡ä»¶ã€‚

* **è¿­ä»£å™¨åè®® (`__iter__`, `__next__`)**:
    * ä½¿ `Cp2kSystems` å¯¹è±¡èƒ½å¤Ÿé€å¸§å¤„ç†æ•°æ®ã€‚
    * `__next__` æ–¹æ³•ä» `.log` å’Œ `.xyz` æ–‡ä»¶è·å–å¹¶å¤„ç†ä¸€å¸§æ•°æ®ï¼Œè¿›è¡Œèƒ½é‡ä¸€è‡´æ€§æ£€æŸ¥ï¼Œç„¶ååˆå¹¶ä¿¡æ¯è¿”å›ä¸€ä¸ªåŒ…å«è¯¥å¸§æ‰€æœ‰æ•°æ®çš„å­—å…¸ã€‚

* **å—ç”Ÿæˆå™¨ (`get_log_block_generator`, `get_xyz_block_generator`)**:
    * `get_log_block_generator`: ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ (`delimiter_patterns`, `avail_patterns`) è¯†åˆ« `.log` æ–‡ä»¶ä¸­æ¯å¸§æ•°æ®çš„è¾¹ç•Œï¼Œå¹¶æŒ‰å¸§è¿”å›æ•°æ®å—ã€‚
    * `get_xyz_block_generator`: æŒ‰æ ‡å‡† `.xyz` æ–‡ä»¶æ ¼å¼ï¼ˆåŸå­æ•°ã€æ³¨é‡Šè¡Œã€åæ ‡æ•°æ®ï¼‰é€å¸§åˆ†å‰²æ•°æ®ã€‚

* **å•å¸§å¤„ç† (`handle_single_log_frame`, `handle_single_xyz_frame`)**:
    * `handle_single_log_frame`:
        * ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼ä» `.log` æ–‡ä»¶çš„ä¸€å¸§æ•°æ®ä¸­æå–å¹¶è½¬æ¢ï¼ˆå¦‚å•ä½æ¢ç®—ï¼‰ä»¥ä¸‹ä¿¡æ¯ï¼š
            * **èƒ½é‡ (Energy)**: Hartree è½¬æ¢ä¸º eVã€‚
            * **æ™¶èƒå‚æ•° (Cell Parameters)**: é•¿åº¦ä» Bohr è½¬ Angstromï¼Œè§’åº¦ä»åº¦è½¬å¼§åº¦ï¼Œç„¶åæ„å»ºæ™¶èƒçŸ©é˜µã€‚
            * **åŸå­å—åŠ› (Forces)**: Hartree/Bohr è½¬æ¢ä¸º eV/Angstromã€‚
            * **åŸå­ç§ç±» (Atomic Kinds)**ã€‚
            * **åº”åŠ›å¼ é‡ (Stress Tensor)**: è½¬æ¢ä¸ºç»´é‡Œ (virial)ï¼Œå•ä½ä» GPa è½¬æ¢ä¸º eV/AngstromÂ³ï¼ˆé€šè¿‡ä¹˜ä»¥ä½“ç§¯ï¼‰ã€‚
            * **æ‰“å°çº§åˆ« (Print Level)**: æ£€æŸ¥ CP2K è¾“å‡ºçº§åˆ«ï¼Œè¿‡ä½åˆ™æŠ¥é”™ã€‚
        * å°†ä¿¡æ¯ç»„ç»‡æˆå­—å…¸è¿”å›ã€‚
    * `handle_single_xyz_frame`:
        * ä» `.xyz` æ–‡ä»¶çš„ä¸€å¸§æ•°æ®ä¸­æå–åŸå­æ•°ã€æ³¨é‡Šè¡Œä¸­çš„èƒ½é‡ï¼ˆHartree è½¬ eVï¼‰ï¼Œä»¥åŠåŸå­ç¬¦å·å’Œåæ ‡ã€‚
        * å°†ä¿¡æ¯ç»„ç»‡æˆå­—å…¸è¿”å›ã€‚

* **å•ä½è½¬æ¢**:
    * å®šä¹‰äº†å¸¸é‡å¦‚ `AU_TO_ANG`, `AU_TO_EV`, `AU_TO_EV_EVERY_ANG` ç”¨äºåŸå­å•ä½åˆ¶åˆ°å¸¸ç”¨å•ä½çš„è½¬æ¢ã€‚

---
### 2. `get_frames` å‡½æ•° ğŸ“‘

æ­¤å‡½æ•°ä¼¼ä¹æ˜¯ä¸€ä¸ªè¾ƒæ—©æˆ–ç®€åŒ–çš„ç‰ˆæœ¬ï¼Œç”¨äºä»å•ä¸ª CP2K è¾“å‡ºæ–‡ä»¶ (é€šå¸¸æ˜¯ `.out` æˆ– `.log` æ–‡ä»¶) ä¸­æå–**æœ€åä¸€å¸§**çš„æ•°æ®ã€‚

#### ä¸»è¦åŠŸèƒ½å’Œç‰¹ç‚¹:

* **è¯»å–ä¸æ£€æŸ¥**: æ‰“å¼€æ–‡ä»¶ï¼Œæ£€æŸ¥è®¡ç®—æ˜¯å¦æ”¶æ•› ("SCF run converged")ã€‚
* **å¤„ç†é‡å¤å¤´éƒ¨**: å®šä½æœ€åä¸€ä¸ªæœ‰æ•ˆæ•°æ®å—çš„å¼€å§‹ï¼Œä»¥å¤„ç†å¯èƒ½çš„é‡å¤è¾“å‡ºã€‚
* **æ•°æ®æå–**:
    * ä»æœ€åä¸€ä¸ªæœ‰æ•ˆæ•°æ®å—ä¸­ï¼Œé€šè¿‡å­—ç¬¦ä¸²åŒ¹é…å’Œåˆ†å‰²æå–æ™¶èƒå‘é‡ã€åŸå­ç§ç±»ã€åæ ‡ã€æ€»èƒ½é‡ã€åŸå­å—åŠ›å’Œåº”åŠ›å¼ é‡ã€‚
* **æ•°æ®è½¬æ¢å’Œæ ¼å¼åŒ–**:
    * æ–‡æœ¬æ•°æ®è½¬ä¸º NumPy æ•°ç»„ï¼Œè°ƒæ•´å½¢çŠ¶ã€‚
    * è¿›è¡Œå•ä½è½¬æ¢ã€‚
    * ç¡®å®šåŸå­åç§°ã€æ•°é‡å’Œç±»å‹æ•°ç»„ã€‚
* **è¿”å›å€¼**: è¿”å›åŒ…å«åŸå­åç§°ã€æ•°é‡ã€ç±»å‹ã€æ™¶èƒã€åæ ‡ã€èƒ½é‡ã€åŠ›å’Œç»´é‡Œ (å¦‚æœå­˜åœ¨) çš„å…ƒç»„ã€‚

---
**æ€»è€Œè¨€ä¹‹ï¼Œè¿™éƒ¨åˆ†ä»£ç çš„æ ¸å¿ƒç›®æ ‡æ˜¯ä¸º `dpdata` æä¾›è§£æ CP2K è¾“å‡ºæ–‡ä»¶çš„èƒ½åŠ›ã€‚`Cp2kSystems` ç±»é€šè¿‡è¿­ä»£å™¨æ¨¡å¼æä¾›äº†æ›´çµæ´»å’Œå¥å£®çš„å¤šå¸§æ•°æ®å¤„ç†ï¼Œèƒ½å¤ŸåŒæ—¶å¤„ç† `.log` å’Œ `.xyz` æ–‡ä»¶ä»¥è·å–å®Œæ•´ä¿¡æ¯ã€‚è€Œ `get_frames` å‡½æ•°åˆ™æä¾›äº†ä¸€ä¸ªä»å•ä¸ªè¾“å‡ºæ–‡ä»¶ä¸­æå–æœ€åä¸€å¸§æ•°æ®çš„åŠŸèƒ½ã€‚ä¸¤è€…éƒ½åŒ…å«äº†å¤æ‚çš„æ–‡æœ¬è§£æé€»è¾‘å’Œå¿…è¦çš„å•ä½è½¬æ¢ã€‚**





# å‚è€ƒèµ„æ–™

- [Source code for dpgen.generator.run](https://docs.deepmodeling.com/projects/dpgen/en/latest/_modules/dpgen/generator/run.html)



